#include "../inc/philo.h"
#include <pthread.h>
#include <unistd.h>

void	eat(t_info *info, int id)
{
	int	left;
	int	right;

	left = id;
	right = (id + 1) % info->num;
	pthread_mutex_lock(&info->philos[left].lock);
	pthread_mutex_lock(&info->philos[right].lock);
	info->philos[id].meals += 1;

	printf("%ld %d %s\n", elap_time(info), id, FORK);
	printf("%ld %d %s\n", elap_time(info), id, EAT);
	usleep(info->t2e);

	info->philos[id].state = THINKING;
	pthread_mutex_unlock(&info->philos[left].lock);
	pthread_mutex_unlock(&info->philos[right].lock);
}

bool	can_eat(t_info *info, int id)
{
	int	left;
	int	right;

	left = (id - 1 + info->num) % info->num;
	right = (id + 1) % info->num;
	if (info->philos[left].state == EATING)
		return (0);
	if (info->philos[right].state == EATING)
		return (0);
	if (info->philos[left].meals < info->philos[id].meals && info->philos[right].meals < info->philos[id].meals)
	{
		return (0);
	}
	return (1);
}

int	proceed(t_info *info, t_philo *phil)
{
	pthread_mutex_lock(&info->lock);
	if (elap_time(info) - phil->last_meal > info->t2d / 1000)
	{
		printf("%ld %d %s\n", elap_time(info), phil->id, DIE);
		info->dead = 1;
	}
	if (info->dead)
	{
		pthread_mutex_unlock(&info->lock);
		return (0);
	}
	pthread_mutex_unlock(&info->lock);
	return (1);
}

void	*phil_rot(void *arg)
{
	t_philo	*phil;
	t_info	*info;
	bool	ate;
	bool	first;

	phil = (t_philo *)arg;
	info = phil->info;
	phil->last_meal = elap_time(info);
	ate = 0;
	first = 1;
	while (proceed(info, phil))
	{
		if ((ate || first) && !can_eat(info, phil->id))
		{
			printf("%ld %d %s\n", elap_time(info), phil->id, THINK);
			ate = 0;
			first = 0;
		}
		if (can_eat(info, phil->id))
		{
			eat(info, phil->id);
			ate = 1;
			if (info->dead)
				break ;
			printf("%ld %d %s\n", elap_time(info), phil->id, SLEEP);
			usleep(info->t2s);
			phil->last_meal = elap_time(info);
		}
		else
			usleep(100);
	}
	return (NULL);
}

int	create_phil(t_info *info)
{
	int	i;

	i = -1;
	while (++i < info->num)
		pthread_create(&info->philos[i].thread, NULL, phil_rot, &info->philos[i]);
	i = 0;
	while (i < info->num)
		pthread_join(info->philos[i++].thread, NULL);
	return (0);
}
